(* ::Package:: *)

(* ::Title:: *)
(*MSSM-to-SMEFT matching at one-loop order*)


(* ::Subtitle:: *)
(*Works  on  Matchete  git commit "f8ed8d53"  (and later):*)
(*[ https://gitlab.com/matchete/matchete/-/commit/5861f833f1447204a5bfc796e8a9cdb67179dc6c ]*)


(* ::Chapter:: *)
(*The computation*)


(* ::Text:: *)
(*Set current directory:*)


SetDirectory@NotebookDirectory[];


(* ::Section:: *)
(*Loading the MSSM*)


(* ::Text:: *)
(*Loading the model:*)


\[ScriptCapitalL]MSSM = LoadModel@FileNameJoin[{NotebookDirectory[], "_MSSM_v2.m"}]


(* ::Subsection::Closed:: *)
(*Restricting to sUp, sCharm, sTop*)


(*
\[ScriptCapitalL]MSSM = \[ScriptCapitalL]MSSM/.{Field[Alternatives@@{(*\[CapitalSigma],*)\[CapitalPhi],lt,et,qt,ut,dt,Gt,Wt(*,Bt*)},___]->0};
*)


(*
\[ScriptCapitalL]MSSM = \[ScriptCapitalL]MSSM/.{Field[Alternatives@@{\[CapitalPhi],lt,et,dt,Gt,Wt},___]->0};
*)


(* ::Subsection::Closed:: *)
(*Print the MSSM Lagrangian:*)


Print["The MSSM Lagrangian is:"];
Print@Format[HcSimplify@\[ScriptCapitalL]MSSM, NiceForm]


(* ::Section::Closed:: *)
(*Tree-level matching*)


(* ::Text:: *)
(*We first perform only the tree-level matching. Calculating the tree-level result separately simplifies the proper treatment of evanescent operators, which only appear at tree level. (One-loop generated evanescent operators only affect two-loop matching calculations.) *)


\[ScriptCapitalL]EFT0= EOMSimplify[
	Match[\[ScriptCapitalL]MSSM, EFTOrder->6, LoopOrder->0]
	,
	ReductionIdentities->dDimensional
];


(* ::Section::Closed:: *)
(*Automatic evanescent operators*)


\[ScriptCapitalL]EFT$TreeLevel= GreensSimplify[Expand[\[ScriptCapitalL]EFT0], ReductionIdentities -> EvanescenceFree]


(* ::Section::Closed:: *)
(*One-loop matching the full MSSM*)


(* ::Text:: *)
(*Perform the one-loop matching, excluding the tree-level results that were computed above.*)


\[ScriptCapitalL]EFT1= EchoTiming[CollectOperators@ Match[\[ScriptCapitalL]MSSM, EFTOrder->6, LoopOrder->{1} (* this excludes the tree-level results *)],"One-loop matching"];


(* ::Section:: *)
(*Simplifying the EFT Lagrangian*)


(* ::Subsection::Closed:: *)
(*Off-Shell*)


(* ::Text:: *)
(*For the one-loop results we can simply apply the four-dimensional Fierz identities, since the evanescent operators generated by this are of two-loop order and can be neglected here.*)


\[ScriptCapitalL]EFT$OneLoop= EchoTiming[GreensSimplify[\[ScriptCapitalL]EFT1,ReductionIdentities->FourDimensional],"Off-shell simplifications"];


(* ::Text:: *)
(*Combine tree-level and one-loop results, giving the full EFT Lagrangian.*)


\[ScriptCapitalL]EFT$OffShell= \[ScriptCapitalL]EFT$TreeLevel + \[ScriptCapitalL]EFT$OneLoop;


(* ::Text:: *)
(*Renormalize in evanescent-free MSbar scheme:*)


(* why is \[ScriptD] still appearing here? *)
\[ScriptCapitalL]EFT$OffShell= Matchete`PackageScope`LagrangianExpand[\[ScriptCapitalL]EFT$OffShell/.(\[ScriptD]->(4-2\[Epsilon]))]/.(\[Epsilon]^-1->0)/.(\[Epsilon]->0);


(* ::Text:: *)
(*Export the resulting EFT Lagrangian*)


Export[FileNameJoin[{"results","MSSM-EFT-Lagrangian_off-shell.m"}], \[ScriptCapitalL]EFT$OffShell];


(* ::Subsection::Closed:: *)
(*On-Shell*)


(* ::Text:: *)
(*Apply the necessary field redefinitions to map to an on-shell basis.*)


\[ScriptCapitalL]EFT$OnShell= EchoTiming[EOMSimplify[
	\[ScriptCapitalL]EFT$OffShell
	,
	DummyCoefficients->True,
	ReductionIdentities->dDimensional
],"Field redefinitions"];


(* ::Text:: *)
(*The field redefinitions can introduce operators that require Fierz identities to be mapped onto the Warsaw basis.*)


\[ScriptCapitalL]EFT$OnShell= EchoTiming[GreensSimplify[
	\[ScriptCapitalL]EFT$OnShell
	,
	ReductionIdentities->EvanescenceFree
],"Fierzing the final results"];


\[ScriptCapitalL]EFT$OnShell$replaced=GreensSimplify[
	EchoTiming[ReplaceEffectiveCouplings@\[ScriptCapitalL]EFT$OnShell, "ReplaceEffectiveCouplings"]
	,
	ReductionIdentities->dDimensional
];


(* ::Text:: *)
(*Export the resulting EFT Lagrangian*)


Export[FileNameJoin[{"results","MSSM-EFT-Lagrangian_on-shell.m"}], \[ScriptCapitalL]EFT$OnShell$replaced];
Export[FileNameJoin[{"results","MSSM-EFT-Lagrangian_on-shell-eff.m"}], \[ScriptCapitalL]EFT$OnShell];


(* ::Section:: *)
(*Mapping to Warsaw basis*)


(* ::Text:: *)
(*In this section the MSSM matching results are mapped onto the Warsaw basis,*)


(* this is just a performance improvement *)
SetOptions[EOMSimplify,DummyCoefficients->True,ReductionIdentities->dDimensional];


(* ::Text:: *)
(*Load the Warsaw basis Lagrangian and Fierz it to the "Matchete basis". This only Fierzes the \!\(TraditionalForm\`*)
(*SubsuperscriptBox[*)
(*StyleBox["Q", "TI"], *)
(*StyleBox[*)
(*RowBox[{"l", "e", "q", "u"}], "TI"], *)
(*RowBox[{"(", "3", ")"}]]\) operator to a leptoquark-like basis to avoid four-fermion tensor structures.*)


\[ScriptCapitalL]Warsaw= EchoTiming[EOMSimplify[
	LoadModel["SMEFT", 
		ModelParameters -> {gs->g3, gL->g2, gY->g1},
		SetModelOptions -> {
			(* NiceForm must be chosen consistently w.r.t. MSSM gauge couplings *)
			{DefineGaugeGroup, SU3c, NiceForm -> {"\!\(\*SubscriptBox[\(g\), \(3\)]\)",Default}},
			{DefineGaugeGroup, SU2L, NiceForm -> {"\!\(\*SubscriptBox[\(g\), \(2\)]\)",Default}},
			{DefineGaugeGroup, U1Y,  NiceForm -> {"\!\(\*SubscriptBox[\(g\), \(1\)]\)",Default}}
		}
	],
	ReductionIdentities -> FourDimensional
]
,"GreensSimplify"];


(* ::Text:: *)
(*Remove all Baryon number violating terms, due to some issues with Fierz identities*)


\[ScriptCapitalL]Warsaw= \[ScriptCapitalL]Warsaw/.{Coupling[cllHH|cduu|cqqq|cqqu|cduq,___]->0};


(* ::Text:: *)
(*Determine the matching conditions in the Warsaw basis.*)


(* remove all poles *)
\[ScriptCapitalL]EFT$OnShell$simpl = CollectOperators[Matchete`PackageScope`BetterExpand[\[ScriptCapitalL]EFT$OnShell]/.\[Epsilon]^-1->0];


MatchingCondition= EchoTiming[
	MapEffectiveCouplings[
		ReplaceEffectiveCouplings[\[ScriptCapitalL]EFT$OnShell$simpl],
		ReplaceEffectiveCouplings[\[ScriptCapitalL]Warsaw]
		,AppendEffectiveCouplingsDefs -> True
		,EOMSimplify                  -> False
		,ReductionIdentities          -> dDimensional
		,ShiftRenCouplings            -> (*True*)False
	]
,"Determining matching conditions"];


(* ::Text:: *)
(*Export the results*)


Export[FileNameJoin[{"results","MSSM-matching-conditions.m"}],MatchingCondition];
